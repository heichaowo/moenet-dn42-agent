"""
WireGuard Mesh Network Renderer

Generates WireGuard IGP mesh tunnels between DN42 nodes for Babel IGP underlay.
Uses single interface with multiple peers to avoid port conflicts.

Key design points:
- AllowedIPs includes ff00::/8 (multicast) and fe80::/10 (link-local) for Babel
- Per-peer loopback /128 for iBGP reachability
- MTU set to 1400 for tunnel overhead
"""
import subprocess
from pathlib import Path
from jinja2 import Template


# Single interface with multiple peers template
# AllowedIPs: ff00::/8 for multicast, fe80::/10 for link-local, peer loopback for IGP
WG_MESH_MULTI_PEER_TEMPLATE = """# WireGuard IGP Mesh - Auto-generated by MoeNet Agent
# Single interface with multiple peers for mesh network
# DO NOT EDIT MANUALLY

[Interface]
PrivateKey = {{ private_key }}
ListenPort = {{ listen_port }}
# MTU reduced for WireGuard overhead (typically 1420, reduced to 1400 for safety)
# This will be set via 'ip link' command, not here

{% for peer in peers %}
[Peer]
# {{ peer.name }} (node_id={{ peer.node_id }})
PublicKey = {{ peer.public_key }}
{% if peer.endpoint %}
Endpoint = {{ peer.endpoint }}:{{ peer.port }}
{% endif %}
{% if loop.first %}
# First peer (usually RR) gets full link-local and multicast ranges
# All Babel traffic goes through this peer, which then reflects routes
AllowedIPs = fe80::/10, ff00::/8, {{ peer.loopback }}/128
{% else %}
# Other peers only get their specific link-local and loopback
# Routes are learned via the first peer (RR) through Babel
AllowedIPs = fe80::{{ peer.node_id }}/128, {{ peer.loopback }}/128
{% endif %}
PersistentKeepalive = 25

{% endfor %}
"""


def generate_wg_keypair() -> tuple[str, str]:
    """Generate a new WireGuard key pair.
    
    Returns:
        Tuple of (private_key, public_key)
    """
    private_key = subprocess.run(
        ["wg", "genkey"],
        capture_output=True,
        text=True,
        check=True
    ).stdout.strip()
    
    public_key = subprocess.run(
        ["wg", "pubkey"],
        input=private_key,
        capture_output=True,
        text=True,
        check=True
    ).stdout.strip()
    
    return private_key, public_key


def get_or_create_mesh_key(key_path: Path) -> tuple[str, str]:
    """Get existing mesh key or create new one.
    
    Args:
        key_path: Path to store/load the private key
        
    Returns:
        Tuple of (private_key, public_key)
    """
    if key_path.exists():
        private_key = key_path.read_text().strip()
        public_key = subprocess.run(
            ["wg", "pubkey"],
            input=private_key,
            capture_output=True,
            text=True,
            check=True
        ).stdout.strip()
        return private_key, public_key
    
    # Generate new key
    private_key, public_key = generate_wg_keypair()
    
    # Save private key
    key_path.parent.mkdir(parents=True, exist_ok=True)
    key_path.write_text(private_key)
    key_path.chmod(0o600)
    
    return private_key, public_key


def render_mesh_config(
    private_key: str,
    listen_port: int,
    peers: list[dict],
) -> str:
    """Render WireGuard mesh interface configuration with multiple peers.
    
    Args:
        private_key: Local WG private key
        listen_port: Local WG listen port
        peers: List of peer dictionaries with keys:
            - name: Peer node name
            - node_id: Peer node ID
            - public_key: Peer WG public key
            - loopback: Peer loopback IPv6 address
            - endpoint: Peer public endpoint (IP or hostname), optional
            - port: Peer WG port
            
    Returns:
        WireGuard configuration string
    """
    template = Template(WG_MESH_MULTI_PEER_TEMPLATE)
    return template.render(
        private_key=private_key,
        listen_port=listen_port,
        peers=peers,
    )


def generate_link_local(node_id: int) -> str:
    """Generate deterministic link-local IPv6 address from node_id.
    
    Uses fe80::{node_id} format for simplicity and determinism.
    
    Args:
        node_id: Node ID (1-65535)
        
    Returns:
        Link-local address string (e.g., "fe80::3")
    """
    return f"fe80::{node_id}"


# Legacy function for backwards compatibility (deprecated)
def render_mesh_interface(
    interface_name: str,
    private_key: str,
    listen_port: int,
    node_id: int,
    peer_name: str,
    peer_public_key: str,
    peer_node_id: int,
    peer_loopback: str,
    peer_endpoint: str | None = None,
    peer_port: int = 51821,
) -> str:
    """DEPRECATED: Use render_mesh_config instead.
    
    This creates per-peer interfaces which causes port conflicts.
    Kept for backwards compatibility but should not be used.
    """
    # Convert to new format
    peers = [{
        "name": peer_name,
        "node_id": peer_node_id,
        "public_key": peer_public_key,
        "loopback": peer_loopback,
        "endpoint": peer_endpoint,
        "port": peer_port,
    }]
    return render_mesh_config(private_key, listen_port, peers)
