"""
WireGuard Mesh Network Renderer

Generates WireGuard IGP mesh tunnels between DN42 nodes for Babel IGP underlay.
Uses single interface with multiple peers to avoid port conflicts.
"""
import subprocess
from pathlib import Path
from jinja2 import Template


# Single interface with multiple peers template
WG_MESH_MULTI_PEER_TEMPLATE = """# WireGuard IGP Mesh - Auto-generated by MoeNet Agent
# Single interface with multiple peers for mesh network
# DO NOT EDIT MANUALLY

[Interface]
PrivateKey = {{ private_key }}
ListenPort = {{ listen_port }}

{% for peer in peers %}
[Peer]
# {{ peer.name }} (node_id={{ peer.node_id }})
PublicKey = {{ peer.public_key }}
{% if peer.endpoint %}
Endpoint = {{ peer.endpoint }}:{{ peer.port }}
{% endif %}
AllowedIPs = fe80::{{ peer.node_id }}/128, {{ peer.loopback }}/128
PersistentKeepalive = 25

{% endfor %}
"""


def generate_wg_keypair() -> tuple[str, str]:
    """Generate a new WireGuard key pair.
    
    Returns:
        Tuple of (private_key, public_key)
    """
    private_key = subprocess.run(
        ["wg", "genkey"],
        capture_output=True,
        text=True,
        check=True
    ).stdout.strip()
    
    public_key = subprocess.run(
        ["wg", "pubkey"],
        input=private_key,
        capture_output=True,
        text=True,
        check=True
    ).stdout.strip()
    
    return private_key, public_key


def get_or_create_mesh_key(key_path: Path) -> tuple[str, str]:
    """Get existing mesh key or create new one.
    
    Args:
        key_path: Path to store/load the private key
        
    Returns:
        Tuple of (private_key, public_key)
    """
    if key_path.exists():
        private_key = key_path.read_text().strip()
        public_key = subprocess.run(
            ["wg", "pubkey"],
            input=private_key,
            capture_output=True,
            text=True,
            check=True
        ).stdout.strip()
        return private_key, public_key
    
    # Generate new key
    private_key, public_key = generate_wg_keypair()
    
    # Save private key
    key_path.parent.mkdir(parents=True, exist_ok=True)
    key_path.write_text(private_key)
    key_path.chmod(0o600)
    
    return private_key, public_key


def render_mesh_config(
    private_key: str,
    listen_port: int,
    peers: list[dict],
) -> str:
    """Render WireGuard mesh interface configuration with multiple peers.
    
    Args:
        private_key: Local WG private key
        listen_port: Local WG listen port
        peers: List of peer dictionaries with keys:
            - name: Peer node name
            - node_id: Peer node ID
            - public_key: Peer WG public key
            - loopback: Peer loopback IPv6 address
            - endpoint: Peer public endpoint (IP or hostname), optional
            - port: Peer WG port
            
    Returns:
        WireGuard configuration string
    """
    template = Template(WG_MESH_MULTI_PEER_TEMPLATE)
    return template.render(
        private_key=private_key,
        listen_port=listen_port,
        peers=peers,
    )


# Legacy function for backwards compatibility (deprecated)
def render_mesh_interface(
    interface_name: str,
    private_key: str,
    listen_port: int,
    node_id: int,
    peer_name: str,
    peer_public_key: str,
    peer_node_id: int,
    peer_loopback: str,
    peer_endpoint: str | None = None,
    peer_port: int = 51821,
) -> str:
    """DEPRECATED: Use render_mesh_config instead.
    
    This creates per-peer interfaces which causes port conflicts.
    Kept for backwards compatibility but should not be used.
    """
    # Convert to new format
    peers = [{
        "name": peer_name,
        "node_id": peer_node_id,
        "public_key": peer_public_key,
        "loopback": peer_loopback,
        "endpoint": peer_endpoint,
        "port": peer_port,
    }]
    return render_mesh_config(private_key, listen_port, peers)
