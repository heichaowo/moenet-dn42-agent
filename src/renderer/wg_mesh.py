"""
WireGuard Mesh Network Renderer (P2P Mode)

Generates WireGuard IGP mesh tunnels between DN42 nodes for Babel IGP underlay.
Uses one interface per peer (P2P mode) for:
- Complete AllowedIPs per interface (no conflicts)
- Per-interface MTU settings (1400 for public, 1420 for private)
- Per-interface Babel cost/metric

Port allocation:
- Base port 51821 + peer_node_id offset
- Example: peer node_id=1 -> port 51821, node_id=2 -> port 51822
"""
import subprocess
from pathlib import Path
from jinja2 import Template


# P2P mode: one interface per peer
WG_MESH_P2P_TEMPLATE = """# WireGuard IGP Mesh - Auto-generated by MoeNet Agent
# Interface: {{ interface_name }}
# Peer: {{ peer_name }} (node_id={{ peer_node_id }})
# DO NOT EDIT MANUALLY

[Interface]
PrivateKey = {{ private_key }}
ListenPort = {{ listen_port }}

[Peer]
# {{ peer_name }}
PublicKey = {{ peer_public_key }}
{% if peer_endpoint %}
Endpoint = {{ peer_endpoint }}:{{ peer_port }}
{% endif %}
# P2P mode: full AllowedIPs (using wg set, no auto-routing)
AllowedIPs = fe80::/10, ff00::/8, {{ peer_loopback }}/128
PersistentKeepalive = 25
"""


def generate_wg_keypair() -> tuple[str, str]:
    """Generate a new WireGuard key pair.
    
    Returns:
        Tuple of (private_key, public_key)
    """
    private_key = subprocess.run(
        ["wg", "genkey"],
        capture_output=True,
        text=True,
        check=True
    ).stdout.strip()
    
    public_key = subprocess.run(
        ["wg", "pubkey"],
        input=private_key,
        capture_output=True,
        text=True,
        check=True
    ).stdout.strip()
    
    return private_key, public_key


def get_or_create_mesh_key(key_path: Path) -> tuple[str, str]:
    """Get existing mesh key or create new one.
    
    Args:
        key_path: Path to store/load the private key
        
    Returns:
        Tuple of (private_key, public_key)
    """
    if key_path.exists():
        private_key = key_path.read_text().strip()
        public_key = subprocess.run(
            ["wg", "pubkey"],
            input=private_key,
            capture_output=True,
            text=True,
            check=True
        ).stdout.strip()
        return private_key, public_key
    
    # Generate new key
    private_key, public_key = generate_wg_keypair()
    
    # Save private key
    key_path.parent.mkdir(parents=True, exist_ok=True)
    key_path.write_text(private_key)
    key_path.chmod(0o600)
    
    return private_key, public_key


def get_mesh_interface_name(peer_node_id: int) -> str:
    """Get interface name for a peer.
    
    Args:
        peer_node_id: Peer's node ID
        
    Returns:
        Interface name (e.g., "dn42-wg-igp-1")
    """
    return f"dn42-wg-igp-{peer_node_id}"


def get_mesh_listen_port(peer_node_id: int, base_port: int = 51820) -> int:
    """Get listen port for a peer interface.
    
    Each peer uses a unique port to avoid binding conflicts.
    
    Args:
        peer_node_id: Peer's node ID
        base_port: Base port number (default 51820)
        
    Returns:
        Listen port (e.g., 51821 for node_id=1)
    """
    return base_port + peer_node_id


def render_mesh_interface(
    private_key: str,
    peer_node_id: int,
    peer_name: str,
    peer_public_key: str,
    peer_loopback: str,
    peer_endpoint: str | None = None,
    peer_port: int | None = None,
    base_port: int = 51820,
) -> tuple[str, str, int]:
    """Render WireGuard mesh interface configuration (P2P mode).
    
    Args:
        private_key: Local WG private key
        peer_node_id: Peer's node ID
        peer_name: Peer node name
        peer_public_key: Peer WG public key
        peer_loopback: Peer loopback IPv6 address
        peer_endpoint: Peer public endpoint (IP or hostname)
        peer_port: Peer WG port (if None, calculated from peer_node_id)
        base_port: Base port for mesh (default 51820)
            
    Returns:
        Tuple of (config_string, interface_name, listen_port)
    """
    interface_name = get_mesh_interface_name(peer_node_id)
    listen_port = get_mesh_listen_port(peer_node_id, base_port)
    
    # Peer's listen port (what we connect to)
    # They listen on base_port + OUR node_id, but we don't know our node_id here
    # So peer_port should be passed in from the caller
    if peer_port is None:
        peer_port = listen_port  # Fallback, but should be overridden
    
    template = Template(WG_MESH_P2P_TEMPLATE)
    config = template.render(
        interface_name=interface_name,
        private_key=private_key,
        listen_port=listen_port,
        peer_name=peer_name,
        peer_node_id=peer_node_id,
        peer_public_key=peer_public_key,
        peer_loopback=peer_loopback,
        peer_endpoint=peer_endpoint,
        peer_port=peer_port,
    )
    
    return config, interface_name, listen_port


def generate_link_local(node_id: int) -> str:
    """Generate deterministic link-local IPv6 address from node_id.
    
    Uses fe80::{node_id} format for simplicity and determinism.
    
    Args:
        node_id: Node ID (1-65535)
        
    Returns:
        Link-local address string (e.g., "fe80::3")
    """
    return f"fe80::{node_id}"


# Legacy function for backwards compatibility
def render_mesh_config(
    private_key: str,
    listen_port: int,
    peers: list[dict],
) -> str:
    """DEPRECATED: Use render_mesh_interface for P2P mode.
    
    This single-interface mode has AllowedIPs conflicts.
    """
    raise NotImplementedError("Single-interface mode deprecated. Use P2P mode with render_mesh_interface().")
