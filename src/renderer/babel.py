"""
Babel IGP Renderer (P2P Mode)

Generates BIRD Babel protocol configuration for IGP underlay.
Supports per-interface cost/metric for P2P mesh mode.

Key design points:
1. RTT cost enabled for tunnel interfaces
2. Type tunnel for WireGuard mesh interfaces
3. Import/export both IPv4 (/32) and IPv6 (/128) loopback addresses
4. Babel only for node-to-node reachability, iBGP for DN42 routes
5. Wildcard interface matching for P2P mode (dn42-wg-igp-*)
"""
from jinja2 import Template


BABEL_TEMPLATE = """# Babel IGP Configuration - Auto-generated by MoeNet Agent
# Purpose: Exchange loopback addresses for iBGP next-hop reachability
# Mode: P2P (one interface per peer)
# DO NOT EDIT MANUALLY

protocol babel babel_igp {
    # P2P mode: each peer has its own interface (dn42-wg-igp-{node_id})
    # Using wildcard to match all mesh interfaces
    
    interface "dn42-wg-igp-*" {
        type tunnel;            # WireGuard is a tunnel interface
        rxcost 32;              # Base cost for tunnel
        
        # RTT-based cost - REQUIRED for mesh networks
        # Significantly increased thresholds for unstable intercontinental links
        rtt cost 96;            # Additional cost based on RTT
        rtt min 200 ms;         # Start adding cost above 200ms (was 100ms)
        rtt max 5000 ms;        # Full cost applied at 5000ms (was 2000ms)
        
        # Large intervals to tolerate multi-second outages
        hello interval 10 s;    # was 6s - allows ~30s before neighbor timeout
        update interval 40 s;   # was 24s
    };
    
    # Dummy0 interface for loopback address announcement
    interface "dummy0" {
        type wired;
        rxcost 1;               # Very low cost for local interface
        hello interval 10 s;    # Synchronized with tunnel interfaces
        update interval 40 s;   # Synchronized with tunnel interfaces
    };
    
    ipv4 {
        # Exchange IPv4 loopback addresses for iBGP next-hop reachability
        import filter {
            # Only accept /32 loopback addresses within our loopback range
            if net.len = 32 && net ~ 172.22.188.0/26 then accept;
            reject;
        };
        export filter {
            # Only export our own loopback address
            if net.len = 32 && net ~ 172.22.188.0/26 then accept;
            reject;
        };
    };
    
    ipv6 {
        # CRITICAL: Only exchange loopback addresses!
        # Never propagate DN42 full table via Babel - use iBGP for that
        import filter {
            # Only accept /128 loopback addresses within our loopback range
            if net.len = 128 && net ~ fd00:4242:7777::/48 then accept;
            reject;
        };
        export filter {
            # Only export our own loopback address
            if net.len = 128 && net ~ fd00:4242:7777::/48 then accept;
            reject;
        };
    };
}
"""


IBGP_PEER_TEMPLATE = """# iBGP Peer: {{ peer_name }}
# Auto-generated by MoeNet Agent
# Uses loopback address for stability (Babel provides reachability)

protocol bgp ibgp_{{ peer_name | replace('.', '_') | replace('-', '_') }} from dn42_internal {
    neighbor {{ peer_loopback }} as {{ asn }};
    description "iBGP to {{ peer_name }}";
{% if is_rr_client %}
    rr client;
{% endif %}
}
"""


def render_babel_config() -> str:
    """Render Babel IGP configuration.
    
    Returns:
        BIRD Babel protocol configuration
    """
    return BABEL_TEMPLATE


def render_ibgp_peer(
    peer_name: str,
    peer_loopback: str,
    asn: int = 4242420998,
    is_rr_client: bool = False,
) -> str:
    """Render iBGP peer configuration using loopback address.
    
    Args:
        peer_name: Peer node name
        peer_loopback: Peer loopback IPv6 address
        asn: Local AS number
        is_rr_client: Whether this peer is an RR client
        
    Returns:
        BIRD iBGP peer configuration
    """
    template = Template(IBGP_PEER_TEMPLATE)
    return template.render(
        peer_name=peer_name,
        peer_loopback=peer_loopback,
        asn=asn,
        is_rr_client=is_rr_client,
    )
